<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î≤ΩÎèåÍπ®Í∏∞ Í≤åÏûÑby seolho pro</title>
    <style>
        body {
            background-color: black;
            color: white;
            display: flexbox;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        canvas {
            border: 3px solid white;
        }
    </style>
</head>
<body>
    <h4>‚ú®Î≤ΩÎèåÍπ®Í∏∞ Í≤åÏûÑ by created seol pro</h4>
    <br>
    <canvas id="gameCanvas"></canvas>
    <script>
        // JavaScript version of the brick breaker game using HTML5 Canvas

        // Ï¥àÍ∏∞ ÏÑ§Ï†ï
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WIDTH = 800;
        const HEIGHT = 600;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;

        // ÏÉâÏÉÅ Ï†ïÏùò
        const COLORS = ['red', 'green', 'blue', 'yellow', 'orange', 'purple'];

        // Ìå®Îì§ ÏÑ§Ï†ï
        const PADDLE_WIDTH = 100;
        const PADDLE_HEIGHT = 10;
        let paddleX = (WIDTH - PADDLE_WIDTH) / 2;
        const paddleSpeed = 6;

        // Í≥µ ÏÑ§Ï†ï
        const BALL_RADIUS = 10;
        let ballX = WIDTH / 2;
        let ballY = HEIGHT / 2;
        let ballSpeedX = 4;
        let ballSpeedY = -4;

        // Î≤ΩÎèå ÏÑ§Ï†ï
        const BRICK_ROWS = 5;
        const BRICK_COLUMNS = 10;
        const BRICK_SPACING = 5;
        const BRICK_WIDTH = (WIDTH - (BRICK_COLUMNS + 1) * BRICK_SPACING) / BRICK_COLUMNS;
        const BRICK_HEIGHT = 30;
        let bricks = [];

        // ÏùåÌñ• Ìö®Í≥º ÏÑ§Ï†ï
        const brickSound = new Audio('sound/brick_hit.wav');
        const paddleSound = new Audio('sound/paddle_hit.wav');
        const winSound = new Audio('sound/win_sound.wav');
        const gameOverSound = new Audio('sound/game_over.wav');

        // Î≤ΩÎèå ÏÉùÏÑ± Ìï®Ïàò
        function createBricks() {
          bricks = [];
          const brickColor = COLORS[Math.floor(Math.random() * COLORS.length)];
          for (let row = 0; row < BRICK_ROWS; row++) {
            for (let col = 0; col < BRICK_COLUMNS; col++) {
              const brickX = col * (BRICK_WIDTH + BRICK_SPACING) + BRICK_SPACING / 2;
              const brickY = row * (BRICK_HEIGHT + BRICK_SPACING) + BRICK_SPACING / 2;
              bricks.push({ x: brickX, y: brickY, color: brickColor, destroyed: false });
            }
          }
          console.log(`Bricks created with color: ${brickColor}`);
        }
        createBricks();

        // ÌÇ§ ÏûÖÎ†• ÏÑ§Ï†ï
        let leftPressed = false;
        let rightPressed = false;
        let paused = false;

        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft') leftPressed = true;
          if (e.key === 'ArrowRight') rightPressed = true;
          if (e.key === 'ArrowUp') paused = true; // ÏÉÅÎã® ÌôîÏÇ¥ÌëúÎ°ú Í≤åÏûÑ ÏùºÏãú Ï†ïÏßÄ
          if (e.key === 'ArrowDown') paused = false; // ÌïòÎã® ÌôîÏÇ¥ÌëúÎ°ú Í≤åÏûÑ Ïû¨Í∞ú
        });

        document.addEventListener('keyup', (e) => {
          if (e.key === 'ArrowLeft') leftPressed = false;
          if (e.key === 'ArrowRight') rightPressed = false;
        });

        // Í≤åÏûÑ Î£®ÌîÑ
        function gameLoop() {
          if (paused) {
            requestAnimationFrame(gameLoop);
            return;
          }

          // ÌôîÎ©¥ Í∑∏Î¶¨Í∏∞
          ctx.clearRect(0, 0, WIDTH, HEIGHT);

          // Ìå®Îì§ Í∑∏Î¶¨Í∏∞
          ctx.fillStyle = 'blue';
          ctx.fillRect(paddleX, HEIGHT - 50, PADDLE_WIDTH, PADDLE_HEIGHT);

          // Í≥µ Í∑∏Î¶¨Í∏∞
          ctx.beginPath();
          ctx.arc(ballX, ballY, BALL_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = 'white';
          ctx.fill();
          ctx.closePath();

          // Î≤ΩÎèå Í∑∏Î¶¨Í∏∞
          bricks.forEach((brick) => {
            if (!brick.destroyed) {
              ctx.fillStyle = brick.color;
              ctx.fillRect(brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT);
            }
          });

          // Ìå®Îì§ Ïù¥Îèô
          if (leftPressed && paddleX > 0) {
            paddleX -= paddleSpeed;
            console.log(`Paddle moved left to position: ${paddleX}`);
          }
          if (rightPressed && paddleX < WIDTH - PADDLE_WIDTH) {
            paddleX += paddleSpeed;
            console.log(`Paddle moved right to position: ${paddleX}`);
          }

          // Í≥µ Ïù¥Îèô
          ballX += ballSpeedX;
          ballY += ballSpeedY;
          console.log(`Ball position updated to: (${ballX}, ${ballY})`);

          // Í≥µÏùò Î≤Ω Ï∂©Îèå
          if (ballX - BALL_RADIUS <= 0 || ballX + BALL_RADIUS >= WIDTH) {
            ballSpeedX = -ballSpeedX;
            console.log(`Ball hit side wall. New speed: (${ballSpeedX}, ${ballSpeedY})`);
          }
          if (ballY - BALL_RADIUS <= 0) {
            ballSpeedY = -ballSpeedY;
            console.log(`Ball hit top wall. New speed: (${ballSpeedX}, ${ballSpeedY})`);
          }
          if (ballY + BALL_RADIUS >= HEIGHT) {
            // Í≤åÏûÑ Ïò§Î≤Ñ Ï°∞Í±¥
            gameOverSound.play();
            console.log('Game over. Ball hit bottom wall.');
            alert('ü§ñÏïÑÏâΩÎÑ§Ïöî, Îã§Ïãú ÎèÑÏ†ÑÌï¥ Î≥¥ÏÑ∏Ïöî');
            createBricks();
            ballX = WIDTH / 2;
            ballY = HEIGHT / 2;
            ballSpeedX = 4;
            ballSpeedY = -4;
            paddleX = (WIDTH - PADDLE_WIDTH) / 2;
            paused = false;
            requestAnimationFrame(gameLoop);
            return;
          }

          // Í≥µÍ≥º Ìå®Îì§Ïùò Ï∂©Îèå
          if (
            ballY + BALL_RADIUS >= HEIGHT - 50 &&
            ballX >= paddleX &&
            ballX <= paddleX + PADDLE_WIDTH
          ) {
            ballSpeedY = -ballSpeedY;
            paddleSound.play();
            console.log(`Ball hit paddle. New speed: (${ballSpeedX}, ${ballSpeedY})`);
          }

          // Í≥µÍ≥º Î≤ΩÎèåÏùò Ï∂©Îèå
          bricks.forEach((brick) => {
            if (!brick.destroyed) {
              if (
                ballX >= brick.x &&
                ballX <= brick.x + BRICK_WIDTH &&
                ballY - BALL_RADIUS <= brick.y + BRICK_HEIGHT &&
                ballY + BALL_RADIUS >= brick.y
              ) {
                ballSpeedY = -ballSpeedY;
                brick.destroyed = true;
                brickSound.play();
                console.log(`Ball hit brick at position: (${brick.x}, ${brick.y}). Brick removed.`);
              }
            }
          });

          // Î™®Îì† Î≤ΩÎèåÏù¥ Íπ®Ï°åÏùÑ Îïå
          if (bricks.every((brick) => brick.destroyed)) {
            console.log('All bricks cleared. Displaying win message.');
            winSound.play();
            alert('Ï∂ïÌïòÌï©ÎãàÎã§. ÏÑ±Í≥µÌñàÏäµÎãàÎã§!');
            createBricks();
            ballX = WIDTH / 2;
            ballY = HEIGHT / 2;
            ballSpeedX = 4;
            ballSpeedY = -4;
            paddleX = (WIDTH - PADDLE_WIDTH) / 2;
            paused = false;
          }

          requestAnimationFrame(gameLoop);
        }

        // Í≤åÏûÑ ÏãúÏûë
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>